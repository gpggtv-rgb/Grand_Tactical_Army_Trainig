

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Grand Tactical Army Training - VER.0.0.3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; touch-action: none; }
        .ui-element { pointer-events: none; user-select: none; }
        @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fade-in 0.8s ease-out forwards; }
        @keyframes wasted-text { 
            0% { transform: scale(0.5) skewX(-18deg); opacity: 0; }
            100% { transform: scale(1) skewX(-18deg); opacity: 1; }
        }
        .animate-wasted { animation: wasted-text 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        .cursor-none { cursor: none; }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@^19.2.3",
        "react-dom/client": "https://esm.sh/react-dom@^19.2.3/client"
      }
    }
    </script>
</head>
<body class="cursor-none">
    <div id="root"></div>
    <script type="module">
        import React, { useState, useRef, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';

        // --- Constants & Config ---
        const TILE_SIZE = 240; 
        const CITY_SIZE = 40;
        const DRAG = 0.985;
        const PLAYER_RUN_SPEED = 5.5;
        const PLAYER_WALK_SPEED = 2.6;
        const ROLL_SPEED = 13.0;
        const ROLL_DURATION = 24; 
        const STAMINA_REGEN = 0.45;
        const STAMINA_RUN_COST = 0.3;
        const THROW_CHARGE_RATE = 0.04; 
        const MAX_THROW_DIST = 5.0;
        const MIN_THROW_DIST = 0.5;

        const COLORS = {
            ROAD: '#1a1a1a', SIDEWALK: '#333333', BUILDING: '#111122', BUILDING_TOP: '#1a1a2e',
            PLAYER: '#00ffcc', PED: '#ffffff', WRECK: '#050505',
            BLOOD: 'rgba(200, 0, 0, 0.7)', SHADOW: 'rgba(0, 0, 0, 0.5)'
        };

        const WeaponTypes = { MELEE: 'MELEE', PISTOL: 'PISTOL', RIFLE: 'RIFLE', THROWABLE: 'THROWABLE' };
        
        const WEAPON_DATA = {
            [WeaponTypes.MELEE]: {
                FIST: { name: 'FIST', damage: 35, cooldown: 20, range: 85, zoomBonus: 0.05, color: '#fca5a5' },
                BAT: { name: 'BAT', damage: 65, cooldown: 26, range: 105, zoomBonus: 0.05, color: '#fde68a' }
            },
            [WeaponTypes.PISTOL]: {
                GLOCK: { name: 'GLOCK', damage: 34, cooldown: 14, zoomBonus: 0.4, color: '#93c5fd' },
                DEAGLE: { name: 'DEAGLE', damage: 98, cooldown: 40, zoomBonus: 0.45, color: '#6366f1' }
            },
            [WeaponTypes.RIFLE]: {
                AK47: { name: 'AK-47', damage: 38, cooldown: 7, zoomBonus: 0.6, color: '#f87171' },
                M249: { name: 'M249', damage: 32, cooldown: 5, zoomBonus: 0.65, color: '#fb923c' }
            },
            [WeaponTypes.THROWABLE]: {
                GRENADE: { name: 'GRENADE', damage: 600, radius: 280, zoomBonus: 0.3, color: '#4ade80' },
                MOLOTOV: { name: 'MOLOTOV', damage: 55, radius: 190, zoomBonus: 0.3, color: '#fbbf24' }
            }
        };

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const playSfx = (freq, type, dur, vol, freqEnd = null) => {
            try {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = type; 
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                if (freqEnd !== null) osc.frequency.exponentialRampToValueAtTime(freqEnd, audioCtx.currentTime + dur);
                g.gain.setValueAtTime(vol, audioCtx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
                osc.connect(g); g.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + dur);
            } catch(e) {}
        };

        const generateMap = () => {
            const grid = [];
            for (let y = 0; y < CITY_SIZE; y++) {
                grid[y] = [];
                for (let x = 0; x < CITY_SIZE; x++) {
                    if (x % 6 === 0 || y % 6 === 0) grid[y][x] = 1; 
                    else if (x % 6 === 1 || x % 6 === 5 || y % 6 === 1 || y % 6 === 5) grid[y][x] = 2; 
                    else grid[y][x] = 3; 
                }
            }
            return grid;
        };

        const GameCanvas = ({ onUpdate, gameKey }) => {
            const canvasRef = useRef(null);
            const engine = useRef({
                player: {
                    id: 'player', pos: { x: TILE_SIZE * 6.5, y: TILE_SIZE * 6.5 }, angle: 0, health: 100, stamina: 100,
                    inventory: {
                        [WeaponTypes.MELEE]: { key: 'FIST', durability: Infinity },
                        [WeaponTypes.PISTOL]: { key: 'GLOCK', ammo: 250 },
                        [WeaponTypes.RIFLE]: { key: 'AK47', ammo: 400 },
                        [WeaponTypes.THROWABLE]: { key: 'GRENADE', ammo: 30 }
                    },
                    selectedSlot: WeaponTypes.MELEE,
                    vehicleId: null, radius: 22, state: 'idle', rollAngle: 0, rollTimer: 0,
                    throwCharge: 0, lastShot: 0, swingTimer: 0, swingSide: 1, aimExtend: 0,
                    transmission: 'auto'
                },
                vehicles: [], peds: [], projectiles: [], particles: [], explosions: [],
                map: generateMap(), keys: {}, mouse: { x: 0, y: 0, left: false, right: false },
                camera: { currentZoom: 0.9 }, lastTime: performance.now(),
                gameTime: 12.0 
            });

            useEffect(() => {
                const eng = engine.current;
                eng.vehicles = []; eng.peds = []; eng.particles = [];
                const vehicleTypes = [
                    { name: 'Sedan', color: '#4466aa', radius: 60, speed: 4.8 },
                    { name: 'SUV', color: '#aa4444', radius: 65, speed: 4.0 },
                    { name: 'Sports', color: '#ccaa22', radius: 58, speed: 6.8 }
                ];

                for (let i = 0; i < 65; i++) {
                    const roadX = Math.floor(Math.random() * 6) * 6;
                    const roadY = Math.floor(Math.random() * CITY_SIZE);
                    const lane = Math.random() > 0.5 ? 1 : -1;
                    const type = vehicleTypes[Math.floor(Math.random() * vehicleTypes.length)];
                    eng.vehicles.push({
                        id: `v-${i}`, pos: { x: roadX * TILE_SIZE + TILE_SIZE/2 + (lane * TILE_SIZE/4), y: roadY * TILE_SIZE },
                        angle: Math.PI / 2, speed: 0, health: 100, gear: 1, type: type.name,
                        color: type.color, radius: type.radius, maxSpeed: type.speed, driver: 'npc', isWreck: false,
                        laneOffset: lane * TILE_SIZE/4, crumpleOffsets: Array(4).fill(0).map(() => ({x:0, y:0})),
                        burnTimer: 0, blockedTimer: 0, reverseTimer: 0
                    });
                }
                for (let i = 0; i < 110; i++) {
                    eng.peds.push({ 
                        id: `p-${i}`, pos: { x: Math.random() * CITY_SIZE * TILE_SIZE, y: Math.random() * CITY_SIZE * TILE_SIZE }, 
                        angle: Math.random() * Math.PI * 2, health: 100, radius: 20, walkTimer: Math.random() * 200,
                        isDead: false, deathTimer: 0, aiState: 'wander', target: null, knockback: { x: 0, y: 0 }
                    });
                }

                const handleKey = (e, down) => {
                    eng.keys[e.code] = down;
                    if (down) {
                        if (e.code === 'Digit1') eng.player.selectedSlot = WeaponTypes.MELEE;
                        if (e.code === 'Digit2') eng.player.selectedSlot = WeaponTypes.PISTOL;
                        if (e.code === 'Digit3') eng.player.selectedSlot = WeaponTypes.RIFLE;
                        if (e.code === 'Digit4') eng.player.selectedSlot = WeaponTypes.THROWABLE;
                        if (e.code === 'KeyF') toggleVehicle();
                        if (e.code === 'KeyQ') eng.player.transmission = eng.player.transmission === 'auto' ? 'manual' : 'auto';
                        if (e.code === 'KeyE' && eng.player.vehicleId && eng.player.transmission === 'manual') {
                            const v = eng.vehicles.find(v => v.id === eng.player.vehicleId);
                            if (v) v.gear = (v.gear % 4) + 1;
                        }
                    }
                };
                window.addEventListener('keydown', (e) => handleKey(e, true));
                window.addEventListener('keyup', (e) => handleKey(e, false));
                window.addEventListener('mousedown', (e) => { if(e.button === 0) eng.mouse.left = true; if(e.button === 2) eng.mouse.right = true; });
                window.addEventListener('mouseup', (e) => { if(e.button === 0) eng.mouse.left = false; if(e.button === 2) eng.mouse.right = false; });
                window.addEventListener('mousemove', (e) => { eng.mouse.x = e.clientX; eng.mouse.y = e.clientY; });
                window.addEventListener('contextmenu', (e) => e.preventDefault());

                const frame = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(frame);
            }, [gameKey]);

            const toggleVehicle = () => {
                const eng = engine.current; const p = eng.player;
                if (p.vehicleId) {
                    const v = eng.vehicles.find(v => v.id === p.vehicleId);
                    if (v) { p.vehicleId = null; v.driver = 'npc'; v.gear = 1; p.pos.x += Math.cos(v.angle + Math.PI/2) * 135; p.pos.y += Math.sin(v.angle + Math.PI/2) * 135; }
                } else {
                    const v = eng.vehicles.find(v => !v.isWreck && Math.hypot(v.pos.x - p.pos.x, v.pos.y - p.pos.y) < 150);
                    if (v) { p.vehicleId = v.id; v.driver = 'player'; v.speed = 0; v.gear = 1; }
                }
            };

            const loop = (time) => {
                const dt = Math.min(1.5, (time - engine.current.lastTime) / 16.67);
                engine.current.lastTime = time;
                engine.current.gameTime = (engine.current.gameTime + (dt * 16.67 / 15000)) % 24;
                for (let i = 0; i < 4; i++) updatePhysics(dt / 4);
                render();
                requestAnimationFrame(loop);
            };

            const spawnBlood = (pos, dir = null) => {
                const eng = engine.current;
                eng.particles.push({
                    type: 'blood', pos: { ...pos }, life: 600, size: 20 + Math.random() * 30, angle: Math.random() * Math.PI * 2,
                    vel: dir ? { x: dir.x * 3, y: dir.y * 3 } : { x: (Math.random()-0.5)*2.5, y: (Math.random()-0.5)*2.5 }
                });
            };

            const updatePhysics = (dt) => {
                const eng = engine.current; const p = eng.player;
                if (p.health <= 0) return;
                
                const isAiming = eng.mouse.right && !p.vehicleId;
                p.aimExtend += (isAiming ? 1 - p.aimExtend : -p.aimExtend) * 0.08 * dt;
                
                eng.vehicles.forEach(v => {
                    if (v.isWreck) { if (v.burnTimer > 0) v.burnTimer -= dt; return; }
                    if (v.driver === 'player') {
                        const gearT = [0, 1.45, 1.1, 0.8, 0.6]; 
                        const gearM = [0, 8.0, 14.5, 21, 30];
                        if (p.transmission === 'auto') {
                            const absSpeed = Math.abs(v.speed);
                            if (absSpeed > 21) v.gear = 4; else if (absSpeed > 14) v.gear = 3; else if (absSpeed > 7) v.gear = 2; else v.gear = 1;
                        }
                        if (eng.keys['KeyS'] && eng.keys['KeyW']) v.speed *= Math.pow(0.72, dt);
                        else if (eng.keys['KeyW']) v.speed = Math.min(gearM[v.gear], v.speed + 0.5 * gearT[v.gear] * dt);
                        else if (eng.keys['KeyS']) v.speed = Math.max(-7.0, v.speed - 0.8 * dt);
                        const turnFac = Math.min(1, Math.abs(v.speed) / 4.5);
                        if (eng.keys['KeyA']) v.angle -= 0.09 * turnFac * dt;
                        if (eng.keys['KeyD']) v.angle += 0.09 * turnFac * dt;
                        v.speed *= Math.pow(DRAG, dt);
                        v.pos.x += Math.cos(v.angle) * v.speed * dt; v.pos.y += Math.sin(v.angle) * v.speed * dt;
                        p.pos = { ...v.pos }; p.angle = v.angle;
                    } else {
                        const entities = [...eng.peds.filter(n => !n.isDead), p];
                        let dangerPed = entities.find(e => Math.hypot(e.pos.x - v.pos.x, e.pos.y - v.pos.y) < 200);
                        let isBlocked = false;
                        const frontX = v.pos.x + Math.cos(v.angle) * 130; const frontY = v.pos.y + Math.sin(v.angle) * 130;
                        if (eng.map[Math.floor(frontY/TILE_SIZE)]?.[Math.floor(frontX/TILE_SIZE)] === 3) isBlocked = true;
                        if (v.reverseTimer > 0) { v.reverseTimer -= dt; v.speed = -3.0; v.angle += 0.025 * dt; }
                        else {
                            if (dangerPed || isBlocked) { v.speed *= Math.pow(0.75, dt); if (Math.abs(v.speed) < 0.25) v.blockedTimer += dt; }
                            else { v.speed = Math.min(v.speed + 0.12 * dt, v.maxSpeed); v.blockedTimer = 0; }
                            if (v.blockedTimer > 120) { v.reverseTimer = 70; v.blockedTimer = 0; }
                        }
                        v.pos.x += Math.cos(v.angle) * v.speed * dt; v.pos.y += Math.sin(v.angle) * v.speed * dt;
                    }
                    checkWall(v);
                });

                if (!p.vehicleId) {
                    if (p.state === 'rolling') {
                        p.pos.x += Math.cos(p.angle) * ROLL_SPEED * dt; p.pos.y += Math.sin(p.angle) * ROLL_SPEED * dt;
                        p.rollTimer -= dt; p.rollAngle = 1.0 - Math.max(0, p.rollTimer / ROLL_DURATION);
                        if (p.rollTimer <= 0) { p.state = 'idle'; p.rollAngle = 0; }
                    } else {
                        const speed = (eng.keys['ShiftLeft'] || isAiming) ? PLAYER_WALK_SPEED : PLAYER_RUN_SPEED;
                        let mx = 0, my = 0;
                        if (eng.keys['KeyW']) my -= 1; if (eng.keys['KeyS']) my += 1;
                        if (eng.keys['KeyA']) mx -= 1; if (eng.keys['KeyD']) mx += 1;
                        if (mx !== 0 || my !== 0) {
                            const inputAng = Math.atan2(my, mx); 
                            p.pos.x += Math.cos(inputAng) * speed * dt; p.pos.y += Math.sin(inputAng) * speed * dt;
                            if (!isAiming) p.angle = inputAng;
                            if (speed > PLAYER_WALK_SPEED) p.stamina = Math.max(0, p.stamina - STAMINA_RUN_COST * dt);
                        } else p.stamina = Math.min(100, p.stamina + STAMINA_REGEN * dt);
                        if (eng.keys['Space'] && p.stamina > 35) { p.state = 'rolling'; p.rollTimer = ROLL_DURATION; p.rollAngle = 0; p.stamina -= 35; playSfx(120, 'sine', 0.2, 0.12, 60); }
                        if (p.selectedSlot === WeaponTypes.THROWABLE) {
                            if (eng.mouse.right) { 
                                p.throwCharge = Math.min(MAX_THROW_DIST, p.throwCharge + (THROW_CHARGE_RATE * dt)); 
                                const c = canvasRef.current; if (c) p.angle = Math.atan2(eng.mouse.y - c.height/2, eng.mouse.x - c.width/2);
                                if (eng.mouse.left && p.throwCharge >= MIN_THROW_DIST) { throwObject(p); p.throwCharge = 0; } 
                            } else p.throwCharge = 0;
                        } else if (eng.mouse.left) fireWeapon(p);
                    }
                    if (isAiming) { const c = canvasRef.current; if (c) p.angle = Math.atan2(eng.mouse.y - c.height/2, eng.mouse.x - c.width/2); }
                    if (p.swingTimer > 0) p.swingTimer -= dt;
                    checkWall(p);
                }

                eng.projectiles = eng.projectiles.filter(pr => {
                    const prevX = pr.pos.x, prevY = pr.pos.y;
                    pr.pos.x += pr.vel.x * dt; pr.pos.y += pr.vel.y * dt; pr.life -= dt;
                    
                    // Projectile Wall Collision
                    const tx = Math.floor(pr.pos.x / TILE_SIZE), ty = Math.floor(pr.pos.y / TILE_SIZE);
                    if (eng.map[ty]?.[tx] === 3) {
                        if (pr.isBomb) { pr.vel.x *= -0.5; pr.vel.y *= -0.5; pr.pos.x = prevX; pr.pos.y = prevY; } 
                        else { pr.life = 0; return false; }
                    }

                    let hit = false;
                    [...eng.peds, p, ...eng.vehicles].forEach(target => {
                        if (target.id === pr.owner || target.health <= 0 || target.isWreck || target.isDead) return;
                        if (Math.hypot(target.pos.x - pr.pos.x, target.pos.y - pr.pos.y) < target.radius + pr.radius) {
                            target.health -= pr.damage; if (!pr.isBomb) hit = true; 
                            if (target.knockback) { target.knockback.x += pr.vel.x * 0.4; target.knockback.y += pr.vel.y * 0.4; }
                            playSfx(450, 'sawtooth', 0.05, 0.12, 220); 
                            if (target.id.startsWith('p-')) { spawnBlood(target.pos, {x: pr.vel.x/35, y: pr.vel.y/35}); if (target.id !== 'player') { target.aiState = 'flee'; target.target = p; } }
                            if (target.health <= 0) { if (target.crumpleOffsets) destroyVehicle(target); else { target.isDead = true; target.deathTimer = 600; playSfx(200, 'square', 0.18, 0.1); } }
                        }
                    });
                    
                    if (pr.life <= 0 && pr.isBomb) { 
                        eng.explosions.push({ pos: { ...pr.pos }, life: 50, radius: pr.bombConfig.radius, damage: pr.bombConfig.damage }); 
                        playSfx(40, 'sawtooth', 0.8, 0.4, 15); 
                    }
                    return !hit && pr.life > 0;
                });

                eng.explosions = eng.explosions.filter(ex => {
                    ex.life -= dt;
                    if (ex.life > 42) {
                        [...eng.peds.filter(n=>!n.isDead), p, ...eng.vehicles.filter(v=>!v.isWreck)].forEach(target => {
                            const d = Math.hypot(target.pos.x - ex.pos.x, target.pos.y - ex.pos.y);
                            if (d < ex.radius) {
                                const distMult = 1 - (d / ex.radius);
                                target.health -= ex.damage * distMult * 0.3;
                                if (target.knockback) {
                                    const nx = (target.pos.x - ex.pos.x)/d, ny = (target.pos.y - ex.pos.y)/d;
                                    target.knockback.x += nx * 30 * distMult; target.knockback.y += ny * 30 * distMult;
                                }
                                if (target.health <= 0) { if (target.crumpleOffsets) destroyVehicle(target); else { target.isDead = true; target.deathTimer = 600; } }
                            }
                        });
                    }
                    return ex.life > 0;
                });

                eng.peds.forEach(npc => {
                    if (npc.isDead) { npc.deathTimer -= dt; return; }
                    if (npc.knockback.x !== 0 || npc.knockback.y !== 0) {
                        npc.pos.x += npc.knockback.x * dt; npc.pos.y += npc.knockback.y * dt;
                        npc.knockback.x *= Math.pow(0.82, dt); npc.knockback.y *= Math.pow(0.82, dt);
                    }
                    if (npc.aiState === 'flee' && npc.target) {
                        npc.angle = Math.atan2(npc.pos.y - npc.target.pos.y, npc.pos.x - npc.target.pos.x);
                        npc.pos.x += Math.cos(npc.angle) * 3.8 * dt; npc.pos.y += Math.sin(npc.angle) * 3.8 * dt;
                    } else {
                        npc.walkTimer -= dt;
                        if (npc.walkTimer <= 0) { npc.angle = Math.random() * Math.PI * 2; npc.walkTimer = 130 + Math.random() * 220; }
                        npc.pos.x += Math.cos(npc.angle) * 2.4 * dt; npc.pos.y += Math.sin(npc.angle) * 2.4 * dt;
                    }
                    checkWall(npc);
                });

                resolveCollisions(dt);
                eng.particles = eng.particles.filter(pa => pa.life > 0);
                onUpdate({ player: p, vehicle: eng.vehicles.find(v => v.id === p.vehicleId), gameTime: eng.gameTime });
            };

            const resolveCollisions = (dt) => {
                const eng = engine.current; const peds = [...eng.peds.filter(n => !n.isDead), eng.player];
                for(let i=0; i<peds.length; i++) {
                    for(let j=i+1; j<peds.length; j++) {
                        const a = peds[i], b = peds[j]; if (a.vehicleId || b.vehicleId) continue;
                        const dist = Math.hypot(b.pos.x - a.pos.x, b.pos.y - a.pos.y); const minDist = a.radius + b.radius;
                        if (dist < minDist) {
                            const overlap = minDist - dist; const nx = (b.pos.x - a.pos.x)/dist, ny = (b.pos.y - a.pos.y)/dist;
                            a.pos.x -= nx * overlap * 0.5; a.pos.y -= ny * overlap * 0.5;
                            b.pos.x += nx * overlap * 0.5; b.pos.y += ny * overlap * 0.5;
                        }
                    }
                }
                const vehs = eng.vehicles.filter(v => !v.isWreck);
                for(let i=0; i<vehs.length; i++) {
                    for(let j=i+1; j<vehs.length; j++) {
                        const a = vehs[i], b = vehs[j];
                        const dist = Math.hypot(b.pos.x - a.pos.x, b.pos.y - a.pos.y); const minDist = a.radius + b.radius - 15;
                        if (dist < minDist) {
                            const overlap = minDist - dist; const nx = (b.pos.x - a.pos.x)/dist, ny = (b.pos.y - a.pos.y)/dist;
                            a.pos.x -= nx * overlap * 0.5; a.pos.y -= ny * overlap * 0.5;
                            b.pos.x += nx * overlap * 0.5; b.pos.y += ny * overlap * 0.5;
                            const avgSpeed = (a.speed + b.speed) / 2; a.speed = avgSpeed * -0.55; b.speed = avgSpeed * -0.55;
                            if (Math.abs(a.speed - b.speed) > 3.5) { a.health -= 12; b.health -= 12; if(a.health <= 0) destroyVehicle(a); if(b.health <= 0) destroyVehicle(b); }
                        }
                    }
                }
                vehs.forEach(v => {
                    peds.forEach(ent => {
                        if (ent.vehicleId === v.id) return;
                        const d = Math.hypot(v.pos.x - ent.pos.x, v.pos.y - ent.pos.y); const minDist = v.radius + ent.radius - 10;
                        if (d < minDist) {
                            const absSpeed = Math.abs(v.speed);
                            if (absSpeed > 1.0) {
                                const damageMult = absSpeed * absSpeed * 2.8; ent.health -= damageMult * dt;
                                if (absSpeed > 2.5) spawnBlood(ent.pos, {x: (ent.pos.x - v.pos.x)/d, y: (ent.pos.y - v.pos.y)/d});
                                if (ent.health <= 0 && ent.id !== 'player') { ent.isDead = true; ent.deathTimer = 600; playSfx(150, 'square', 0.25, 0.2, 50); }
                            }
                            const nx = (ent.pos.x - v.pos.x)/d, ny = (ent.pos.y - v.pos.y)/d;
                            const pushForce = Math.max(14, absSpeed * 7.5); ent.pos.x += nx * pushForce; ent.pos.y += ny * pushForce;
                            if (ent.knockback) { ent.knockback.x += nx * absSpeed * 3.5; ent.knockback.y += ny * absSpeed * 3.5; }
                            v.speed *= 0.9;
                        }
                    });
                });
            };

            const fireWeapon = (p) => {
                const eng = engine.current; const slot = p.inventory[p.selectedSlot]; const config = WEAPON_DATA[p.selectedSlot][slot.key];
                if (!config || Date.now() - p.lastShot < config.cooldown * 16.6) return;
                p.lastShot = Date.now();
                if (p.selectedSlot === WeaponTypes.MELEE) {
                    p.swingTimer = 15; p.swingSide *= -1; playSfx(150, 'square', 0.1, 0.15, 80);
                    eng.peds.forEach(npc => {
                        if (npc.isDead) return;
                        const d = Math.hypot(npc.pos.x - p.pos.x, npc.pos.y - p.pos.y); const a = Math.atan2(npc.pos.y - p.pos.y, npc.pos.x - p.pos.x);
                        if (d < config.range && Math.abs(((a - p.angle + Math.PI*3) % (Math.PI*2)) - Math.PI) < 1.0) {
                            npc.health -= config.damage; npc.aiState = 'flee'; npc.target = p;
                            npc.knockback.x = Math.cos(p.angle) * 18; npc.knockback.y = Math.sin(p.angle) * 18;
                            playSfx(350, 'sawtooth', 0.08, 0.1, 100);
                        }
                    });
                } else if (p.selectedSlot !== WeaponTypes.THROWABLE) {
                    if (slot.ammo <= 0) return; slot.ammo--; playSfx(800, 'sawtooth', 0.05, 0.2, 550);
                    eng.projectiles.push({ pos: { x: p.pos.x + Math.cos(p.angle)*40, y: p.pos.y + Math.sin(p.angle)*40 }, vel: { x: Math.cos(p.angle)*50, y: Math.sin(p.angle)*50 }, owner: 'player', life: 40, radius: 5, damage: config.damage, color: config.color });
                }
            };

            const throwObject = (p) => {
                const eng = engine.current; const slot = p.inventory[WeaponTypes.THROWABLE]; const config = WEAPON_DATA[WeaponTypes.THROWABLE][slot.key];
                if (slot.ammo <= 0) return; slot.ammo--;
                const travelDist = p.throwCharge * TILE_SIZE; const speed = 14;
                eng.projectiles.push({ pos: { x: p.pos.x, y: p.pos.y }, vel: { x: Math.cos(p.angle) * speed, y: Math.sin(p.angle) * speed }, owner: 'player', life: travelDist / speed, radius: 10, damage: 0, isBomb: true, bombConfig: config, color: config.color });
                playSfx(350, 'sine', 0.12, 0.15, 120);
            };

            const destroyVehicle = (v) => { v.isWreck = true; v.speed = 0; v.burnTimer = 250; playSfx(50, 'sawtooth', 1.0, 0.45, 10); };
            
            const checkWall = (ent) => {
                const { map } = engine.current; const tx = Math.floor(ent.pos.x / TILE_SIZE), ty = Math.floor(ent.pos.y / TILE_SIZE);
                for (let y = ty-1; y <= ty+1; y++) {
                    for (let x = tx-1; x <= tx+1; x++) {
                        if (map[y]?.[x] === 3) {
                            const bX = x * TILE_SIZE, bY = y * TILE_SIZE; const cX = Math.max(bX, Math.min(ent.pos.x, bX + TILE_SIZE)), cY = Math.max(bY, Math.min(ent.pos.y, bY + TILE_SIZE));
                            const dx = ent.pos.x - cX, dy = ent.pos.y - cY; const d = Math.hypot(dx, dy);
                            if (d < ent.radius && d > 0) {
                                ent.pos.x += (dx/d) * (ent.radius - d); ent.pos.y += (dy/d) * (ent.radius - d);
                                if (ent.speed) { 
                                    if (Math.abs(ent.speed) > 4.5 && ent.crumpleOffsets) { ent.health -= Math.abs(ent.speed)*4.0; ent.crumpleOffsets = ent.crumpleOffsets.map(o => ({ x: o.x + (Math.random()-0.5)*18, y: o.y + (Math.random()-0.5)*18 })); if (ent.health<=0) destroyVehicle(ent); } 
                                    ent.speed *= -0.48; 
                                }
                            }
                        }
                    }
                }
            };

            const render = () => {
                const canvas = canvasRef.current; if (!canvas) return;
                const ctx = canvas.getContext('2d'); const eng = engine.current; const p = eng.player;
                canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                
                const v = eng.vehicles.find(v => v.id === p.vehicleId); const weaponSlot = p.inventory[p.selectedSlot]; const wConfig = WEAPON_DATA[p.selectedSlot][weaponSlot.key];
                const isNight = eng.gameTime < 6 || eng.gameTime > 19;
                const baseZoom = v ? (0.42 - Math.abs(v.speed)*0.01) : 0.88; const zoomT = (baseZoom - (p.aimExtend * wConfig.zoomBonus)) * (isNight ? 0.72 : 1);
                eng.camera.currentZoom += (zoomT - eng.camera.currentZoom) * 0.08;
                const ambientBrightness = isNight ? 0.02 : Math.sin((eng.gameTime - 6) * Math.PI / 12) * 0.5 + 0.35;
                const sunAngle = (eng.gameTime - 12) * Math.PI / 12;
                const shadowOffX = Math.cos(sunAngle) * 14; const shadowOffY = Math.sin(sunAngle) * 14;
                
                ctx.fillStyle = isNight ? '#020208' : '#0a0a1a'; ctx.fillRect(0,0, canvas.width, canvas.height);
                ctx.save(); ctx.translate(canvas.width/2, canvas.height/2); ctx.scale(eng.camera.currentZoom, eng.camera.currentZoom); ctx.translate(-p.pos.x, -p.pos.y);

                if (p.health <= 0) ctx.filter = 'grayscale(100%)';

                for (let y = 0; y < CITY_SIZE; y++) {
                    for (let x = 0; x < CITY_SIZE; x++) {
                        const t = eng.map[y][x]; const px = x * TILE_SIZE, py = y * TILE_SIZE;
                        if (t === 1) { ctx.fillStyle = COLORS.ROAD; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
                        else if (t === 2) { ctx.fillStyle = COLORS.SIDEWALK; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
                        else if (t === 3) { 
                            ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(px + shadowOffX*2.2, py + shadowOffY*2.2, TILE_SIZE, TILE_SIZE); 
                            ctx.fillStyle = COLORS.BUILDING; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); 
                            ctx.fillStyle = COLORS.BUILDING_TOP; ctx.fillRect(px+32, py+32, TILE_SIZE-64, TILE_SIZE-64); 
                        }
                    }
                }

                const drawShadow = (pos, radius, scaleY = 0.5) => {
                    ctx.save(); ctx.translate(pos.x + shadowOffX, pos.y + shadowOffY); ctx.scale(1, scaleY); ctx.fillStyle = COLORS.SHADOW; ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI * 2); ctx.fill(); ctx.restore();
                };
                eng.vehicles.forEach(veh => drawShadow(veh.pos, veh.radius * 1.15, 0.6));
                eng.peds.forEach(ped => { if(!ped.isDead) drawShadow(ped.pos, ped.radius * 1.25); });
                if(!p.vehicleId) drawShadow(p.pos, p.radius * 1.25);

                eng.particles.forEach(pa => { if (pa.type === 'blood') { ctx.fillStyle = COLORS.BLOOD; ctx.globalAlpha = Math.min(1, pa.life/200); ctx.beginPath(); ctx.arc(pa.pos.x, pa.pos.y, pa.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; } });
                eng.peds.forEach(ped => { if (ped.isDead) { ctx.save(); ctx.translate(ped.pos.x, ped.pos.y); ctx.globalAlpha = Math.min(1, ped.deathTimer/250); ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(0,0, ped.radius, 0, Math.PI*2); ctx.fill(); ctx.restore(); } });

                eng.vehicles.forEach(veh => {
                    ctx.save(); ctx.translate(veh.pos.x, veh.pos.y); ctx.rotate(veh.angle);
                    if (!veh.isWreck) {
                        const isRev = (veh.driver === 'player' && veh.speed < 0) || (veh.driver === 'npc' && veh.speed < 0);
                        const isBrake = (veh.driver === 'player' && eng.keys['KeyS'] && veh.speed > 0.05);
                        const headGrad = ctx.createRadialGradient(45, 0, 15, isNight ? 480 : 280, 0, isNight ? 350 : 200);
                        headGrad.addColorStop(0, isNight ? 'rgba(255,255,200,0.65)' : 'rgba(255,255,200,0.25)'); headGrad.addColorStop(1, 'transparent');
                        ctx.fillStyle = headGrad; ctx.beginPath(); ctx.moveTo(40, -35); ctx.lineTo(isNight ? 520 : 300, -130); ctx.lineTo(isNight ? 520 : 300, 130); ctx.lineTo(40, 35); ctx.fill();
                        if (isRev || isBrake || isNight) {
                            const intensity = isBrake ? 0.98 : (isRev ? 0.7 : 0.4);
                            const tailGrad = ctx.createRadialGradient(-45, 0, 10, -150, 0, 120);
                            tailGrad.addColorStop(0, isRev ? `rgba(255,255,255,${intensity})` : `rgba(255,0,0,${intensity})`);
                            tailGrad.addColorStop(1, 'transparent');
                            ctx.fillStyle = tailGrad; ctx.beginPath(); ctx.moveTo(-40, -32); ctx.lineTo(-190, -95); ctx.lineTo(-190, 95); ctx.lineTo(-40, 32); ctx.fill();
                            ctx.fillStyle = isRev ? '#fff' : (isBrake ? '#ff0000' : '#aa0000');
                            ctx.shadowBlur = isBrake ? 25 : 0; ctx.shadowColor = '#ff0000';
                            ctx.fillRect(-58, -28, 6, 14); ctx.fillRect(-58, 14, 6, 14); ctx.shadowBlur = 0;
                        }
                    }
                    ctx.fillStyle = veh.isWreck ? COLORS.WRECK : veh.color; const w = 58, h = 33;
                    ctx.beginPath(); ctx.moveTo(-w+veh.crumpleOffsets[0].x, -h+veh.crumpleOffsets[0].y); ctx.lineTo(w+veh.crumpleOffsets[1].x, -h+veh.crumpleOffsets[1].y); ctx.lineTo(w+veh.crumpleOffsets[2].x, h+veh.crumpleOffsets[2].y); ctx.lineTo(-w+veh.crumpleOffsets[3].x, h+veh.crumpleOffsets[3].y); ctx.closePath(); ctx.fill();
                    if (!veh.isWreck) { ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fillRect(-35, -28, 70, 56); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(25, -24, 15, 48); ctx.fillRect(-45, -24, 10, 48); }
                    if (veh.burnTimer > 0) { ctx.fillStyle = `rgba(255, ${120 + Math.random()*135}, 0, 0.9)`; ctx.beginPath(); ctx.arc((Math.random()-0.5)*35, (Math.random()-0.5)*35, 45*Math.random(), 0, Math.PI*2); ctx.fill(); }
                    ctx.restore();
                });

                const drawChar = (c, isP) => {
                    if (isP && c.vehicleId) return;
                    ctx.save(); ctx.translate(c.pos.x, c.pos.y); 
                    if (isP && c.state === 'rolling') ctx.rotate(c.angle + (c.rollAngle * Math.PI * 2)); else ctx.rotate(c.angle);
                    ctx.fillStyle = isP ? COLORS.PLAYER : COLORS.PED; ctx.beginPath(); ctx.arc(0,0, c.radius, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'black'; ctx.fillRect(16, -4, 10, 8); 
                    if (isP && c.swingTimer > 0) { ctx.fillStyle = COLORS.PLAYER; const ext = Math.sin(c.swingTimer * 0.25) * 35; ctx.beginPath(); ctx.arc(26 + ext, 16 * c.swingSide, 11, 0, Math.PI*2); ctx.fill(); }
                    ctx.restore();
                };
                eng.peds.forEach(ped => { if(!ped.isDead) drawChar(ped, false); }); drawChar(p, true);
                
                eng.projectiles.forEach(pr => { ctx.fillStyle = pr.color || '#fff'; ctx.shadowBlur = 20; ctx.shadowColor = pr.color || '#fff'; ctx.beginPath(); ctx.arc(pr.pos.x, pr.pos.y, pr.radius, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0; });
                eng.explosions.forEach(ex => { ctx.fillStyle = `rgba(255, 150, 0, ${ex.life/50})`; ctx.beginPath(); ctx.arc(ex.pos.x, ex.pos.y, ex.radius * (1 - ex.life/50), 0, Math.PI*2); ctx.fill(); });
                ctx.restore();

                const vision = (1050 + (p.aimExtend * 850) + (p.vehicleId ? 480 : 0)) / eng.camera.currentZoom;
                const fogIntensity = isNight ? 0.998 : 0.95 - (ambientBrightness * 0.06);
                const fogGrad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, vision*0.3, canvas.width/2, canvas.height/2, vision*1.95);
                fogGrad.addColorStop(0, 'transparent'); fogGrad.addColorStop(0.5, `rgba(0,0,0,${fogIntensity * 0.5})`); fogGrad.addColorStop(1, `rgba(0,0,0,${fogIntensity})`);
                ctx.fillStyle = fogGrad; ctx.fillRect(0,0, canvas.width, canvas.height);

                const isAimingFirearm = p.aimExtend > 0.1 && (p.selectedSlot === WeaponTypes.PISTOL || p.selectedSlot === WeaponTypes.RIFLE);
                if (isAimingFirearm) {
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.arc(eng.mouse.x, eng.mouse.y, 12, 0, Math.PI*2); ctx.moveTo(eng.mouse.x - 18, eng.mouse.y); ctx.lineTo(eng.mouse.x + 18, eng.mouse.y); ctx.moveTo(eng.mouse.x, eng.mouse.y - 18); ctx.lineTo(eng.mouse.x, eng.mouse.y + 18); ctx.stroke();
                } else if (p.selectedSlot === WeaponTypes.THROWABLE && eng.mouse.right) {
                    ctx.strokeStyle = '#4ade80'; ctx.lineWidth = 3; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.arc(eng.mouse.x, eng.mouse.y, 15 + (p.throwCharge * 10), 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
                } else {
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(eng.mouse.x, eng.mouse.y, 4, 0, Math.PI*2); ctx.fill();
                }

                const mapS = 220; const mapX = canvas.width - mapS - 30; const mapY = canvas.height - mapS - 30;
                ctx.fillStyle = 'rgba(0,0,0,0.96)'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.fillRect(mapX, mapY, mapS, mapS); ctx.strokeRect(mapX, mapY, mapS, mapS);
                ctx.save(); ctx.beginPath(); ctx.rect(mapX, mapY, mapS, mapS); ctx.clip(); ctx.translate(mapX + mapS/2, mapY + mapS/2); ctx.scale(0.018, 0.018); ctx.translate(-p.pos.x, -p.pos.y);
                for (let y = 0; y < CITY_SIZE; y++) { for (let x = 0; x < CITY_SIZE; x++) { if (eng.map[y][x] === 3) { ctx.fillStyle = '#111122'; ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE); } } }
                eng.peds.forEach(ped => { if(!ped.isDead && Math.hypot(ped.pos.x-p.pos.x, ped.pos.y-p.pos.y) < 1600) { ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(ped.pos.x, ped.pos.y, 130, 0, Math.PI*2); ctx.fill(); } });
                ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.arc(p.pos.x, p.pos.y, 180, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            };
            return React.createElement('canvas', { ref: canvasRef });
        };

        const App = () => {
            const [gameKey, setGameKey] = useState(0);
            const [state, setState] = useState({ player: { health: 100, stamina: 100, inventory: {}, selectedSlot: WeaponTypes.MELEE, transmission: 'auto' }, vehicle: null, gameTime: 12 });
            const slots = [WeaponTypes.MELEE, WeaponTypes.PISTOL, WeaponTypes.RIFLE, WeaponTypes.THROWABLE];
            const formatTime = (t) => {
                const h24 = Math.floor(t); const m = Math.floor((t % 1) * 60); const ampm = h24 >= 12 ? 'PM' : 'AM'; const h12 = h24 % 12 || 12;
                return `${h12.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')} ${ampm}`;
            };
            return React.createElement('div', { className: 'relative w-screen h-screen bg-black text-white overflow-hidden font-mono select-none' },
                React.createElement(GameCanvas, { key: gameKey, gameKey, onUpdate: setState }),
                React.createElement('div', { className: 'absolute bottom-2 right-2 text-[10px] opacity-30 ui-element flex flex-col items-end' }, 
                    React.createElement('span', null, 'VER.0.0.3'),
                    React.createElement('span', null, '[release: alpha-3]')
                ),
                React.createElement('div', { className: 'absolute top-6 left-6 flex flex-col gap-4 ui-element' },
                    React.createElement('div', { className: 'bg-black/90 border-l-8 border-yellow-500 px-6 py-2 text-yellow-400 text-6xl font-black italic shadow-lg' }, formatTime(state.gameTime)),
                    React.createElement('div', { className: 'w-80 space-y-2' },
                        React.createElement('div', { className: 'h-7 bg-gray-950 border-2 border-white/20 p-1' }, React.createElement('div', { className: 'h-full bg-red-600 shadow-[0_0_20px_red]', style: { width: `${state.player.health}%` } })),
                        React.createElement('div', { className: 'h-3.5 bg-gray-950 border-2 border-white/20 p-0.5' }, React.createElement('div', { className: 'h-full bg-blue-500 shadow-[0_0_12px_blue]', style: { width: `${state.player.stamina}%` } }))
                    )
                ),
                React.createElement('div', { className: 'absolute top-6 right-6 flex gap-3 p-4 bg-black/85 border-b-4 border-yellow-500 rounded-xl ui-element' },
                    slots.map((s, i) => {
                        const inv = state.player.inventory[s]; const active = state.player.selectedSlot === s;
                        return React.createElement('div', { key: s, className: `w-24 h-24 border-2 transition-all flex flex-col items-center justify-center ${active ? 'border-yellow-400 bg-yellow-400/25 scale-110 shadow-lg' : 'border-white/10 opacity-60'}` },
                            React.createElement('div', { className: 'text-[10px] opacity-40' }, i+1),
                            React.createElement('div', { className: 'text-[10px] font-bold text-center px-1' }, inv?.key || 'EMPTY'),
                            React.createElement('div', { className: 'text-[13px] mt-1 text-yellow-500 font-bold' }, inv?.ammo ?? '')
                        );
                    })
                ),
                state.vehicle && React.createElement('div', { className: 'absolute bottom-6 left-1/2 -translate-x-1/2 flex flex-col items-center gap-1 ui-element' },
                    React.createElement('div', { className: 'flex gap-4' },
                        React.createElement('div', { className: 'bg-black/80 px-4 py-1 border-2 border-white rounded-lg text-xs' }, `MODE: ${state.player.transmission.toUpperCase()}`),
                        React.createElement('div', { className: 'bg-black/80 px-4 py-1 border-2 border-yellow-500 rounded-lg text-xs text-yellow-400 font-bold' }, `GEAR: ${state.vehicle.gear}`)
                    ),
                    React.createElement('div', { className: 'bg-black/80 px-6 py-2 border-2 border-white rounded-xl text-3xl font-black italic flex items-baseline gap-2' },
                        React.createElement('span', null, Math.floor(Math.abs(state.vehicle.speed) * 32)),
                        React.createElement('span', { className: 'text-xs opacity-50' }, 'KM/H')
                    )
                ),
                React.createElement('div', { className: 'absolute bottom-6 left-6 text-[10px] opacity-40 ui-element flex flex-col gap-1' },
                    React.createElement('span', null, 'WASD: MOVE | F: EXIT | Q: TRANSMISSION | 1-4: SLOTS'),
                    React.createElement('span', null, 'SPACE: ROLL (INVINCIBLE FRAMES) | SHIFT: WALK'),
                    React.createElement('span', null, 'RMB: AIM | LMB: FIRE/THROW | TAB: RELOAD (UI ONLY)')
                ),
                state.player.health <= 0 && React.createElement('div', { className: 'absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-50 animate-fade-in' },
                    React.createElement('h1', { className: 'text-white text-9xl font-black mb-12 animate-wasted' }, 'WASTED'),
                    React.createElement('button', { className: 'px-24 py-6 bg-white text-black font-black text-3xl hover:bg-yellow-400 transition-all pointer-events-auto shadow-[0_0_30px_white]', onClick: () => { localStorage.clear(); setGameKey(k => k+1); } }, 'RESPAWN')
                )
            );
        };
        createRoot(document.getElementById('root')).render(React.createElement(App));
    </script>
</body>
</html>
